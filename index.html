<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Circle Breaker with Bond Tool & Settings</title>
<style>
  body, html {
    margin: 0; padding: 0; overflow: hidden; height: 100vh; background: #222;
    user-select: none;
    font-family: Arial, sans-serif;
  }
  #gameCanvas {
    display: block;
    background: #333;
  }
  #toolbar {
    position: fixed;
    bottom: 0; left: 0; right: 0;
    height: 50px;
    background: #111;
    display: flex;
    align-items: center;
    justify-content: space-around;
    border-top: 2px solid #555;
  }
  #toolbar button {
    background: #444;
    border: none;
    color: white;
    padding: 8px 15px;
    font-size: 16px;
    cursor: pointer;
    border-radius: 5px;
    transition: background 0.3s;
  }
  #toolbar button.active {
    background: #0a84ff;
  }
  #settingsBtn.active {
    background: #0a84ff;
  }
  /* Update the positioning of the panels to appear above their buttons */
  #settingsPanel, #bondSettingsPanel, #dragSettingsPanel {
    position: absolute;
    bottom: 60px; /* Position above the toolbar */
    background: #111;
    padding: 15px;
    border-radius: 8px;
    color: white;
    display: none;
    min-width: 280px;
    box-shadow: 0 0 15px #0a84ff;
    font-size: 14px;
    z-index: 100;
  }

  /* Position each panel above its respective button */
  #settingsPanel {
    left: 50%;
    transform: translateX(-50%);
  }

  #bondSettingsPanel {
    left: 50%;
    transform: translateX(-50%);
  }

  #dragSettingsPanel {
    left: 50%;
    transform: translateX(-50%);
  }
  #settingsPanel label, #bondSettingsPanel label {
    display: block;
    margin: 8px 0 4px;
  }
  #settingsPanel input[type="range"], #bondSettingsPanel input[type="range"] {
    width: 100%;
  }
  #bondSettingsPanel .bond-type {
    margin-bottom: 10px;
  }
  #bondSettingsPanel .checkbox-group {
    margin-top: 10px;
  }
  #bondSettingsPanel .checkbox-group label {
    display: flex;
    align-items: center;
    gap: 8px;
  }
  #dragSettingsPanel {
    position: fixed;
    bottom: 60px;
    left: 50%;
    transform: translateX(-50%);
    background: #111;
    padding: 15px;
    border-radius: 8px;
    color: white;
    display: none;
    min-width: 280px;
    box-shadow: 0 0 15px #0a84ff;
    font-size: 14px;
  }
  #dragSettingsPanel .checkbox-group {
    margin-top: 10px;
  }
  #dragSettingsPanel .checkbox-group label {
    display: flex;
    align-items: center;
    gap: 8px;
  }
  /* Add styles for pause button and freeze tool */
  #pauseBtn {
    position: fixed;
    top: 10px;
    right: 10px;
    background: #444;
    border: none;
    color: white;
    padding: 8px 15px;
    font-size: 16px;
    cursor: pointer;
    border-radius: 5px;
    transition: background 0.3s;
    z-index: 100;
  }
  #pauseBtn.paused {
    background: #ff3b30;
  }
  #freezeBtn {
    background: #444;
  }
  #freezeBtn.active {
    background: #5856d6;
  }
  .frozen {
    stroke: #5856d6;
    stroke-width: 3px;
  }
  /* Styles for create settings panel */
  #createSettingsPanel {
    position: absolute;
    bottom: 60px;
    background: #111;
    padding: 15px;
    border-radius: 8px;
    color: white;
    display: none;
    min-width: 280px;
    box-shadow: 0 0 15px #0a84ff;
    font-size: 14px;
    z-index: 100;
  }

  #createSettingsPanel .state-tabs {
    display: flex;
    justify-content: space-between;
    margin-bottom: 15px;
  }

  #createSettingsPanel .state-tabs button {
    background: #444;
    border: none;
    color: white;
    padding: 8px 15px;
    font-size: 14px;
    cursor: pointer;
    border-radius: 5px;
    flex-grow: 1;
    margin: 0 5px;
    transition: background 0.3s;
  }

  #createSettingsPanel .state-tabs button:first-child {
    margin-left: 0;
  }

  #createSettingsPanel .state-tabs button:last-child {
    margin-right: 0;
  }

  #createSettingsPanel .state-tabs button.active {
    background: #0a84ff;
  }

  #createSettingsPanel .color-sliders {
    margin-top: 15px;
    border-top: 1px solid #333;
    padding-top: 15px;
  }

  #createSettingsPanel .color-sliders label {
    display: block;
    margin: 8px 0 4px;
  }

  #createSettingsPanel .color-sliders input[type="range"] {
    width: 100%;
  }

  #createSettingsPanel .color-preview {
    width: 100%;
    height: 30px;
    margin-top: 10px;
    border-radius: 5px;
    background: rgb(10, 132, 255);
    border: 1px solid #555;
  }

  /* Update styles for the slider header and buttons */
  #createSettingsPanel .slider-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
  }

  #createSettingsPanel .button-group {
    display: flex;
    gap: 5px;
  }

  #createSettingsPanel .small-btn {
    background: #444;
    border: none;
    color: white;
    padding: 4px 8px;
    font-size: 12px;
    cursor: pointer;
    border-radius: 3px;
    transition: background 0.3s;
  }

  #createSettingsPanel .small-btn:hover {
    background: #555;
  }

  /* Add styles for slider groups and reset buttons in settings panel */
  #settingsPanel .slider-group {
    margin-bottom: 15px;
  }

  #settingsPanel .slider-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 5px;
  }

  #settingsPanel .small-btn {
    background: #444;
    border: none;
    color: white;
    padding: 4px 8px;
    font-size: 12px;
    cursor: pointer;
    border-radius: 3px;
    transition: background 0.3s;
  }

  #settingsPanel .small-btn:hover {
    background: #555;
  }
  /* Add styles for disabled checkbox */
  #dragSettingsPanel .checkbox-group label.disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  #dragSettingsPanel .checkbox-group label.disabled input {
    cursor: not-allowed;
  }
</style>
</head>
<body>

<canvas id="gameCanvas"></canvas>

<button id="pauseBtn">Pause</button>

<div id="toolbar">
  <button id="createBtn" class="active">Create</button>
  <button id="dragBtn">Drag</button>
  <button id="freezeBtn">Freeze</button>
  <button id="bondBtn">Bond</button>
  <button id="settingsBtn">Settings</button>
  <button id="resetBtn">Reset</button>
</div>

<div id="settingsPanel">
  <div class="slider-group">
    <div class="slider-header">
      <label for="gravityRange">Gravity: <span id="gravityVal">0.5</span></label>
      <button class="small-btn reset-btn" data-slider="gravity" data-default="0.5">Reset</button>
    </div>
    <input type="range" id="gravityRange" min="-10" max="10" step="0.1" value="0.5" />
  </div>

  <div class="slider-group">
    <div class="slider-header">
      <label for="dragStrengthRange">Drag Strength: <span id="dragStrengthVal">0.10</span></label>
      <button class="small-btn reset-btn" data-slider="dragStrength" data-default="0.10">Reset</button>
    </div>
    <input type="range" id="dragStrengthRange" min="-10" max="10" step="0.01" value="0.10" />
  </div>

  <div class="slider-group">
    <div class="slider-header">
      <label for="airResistanceRange">Air Resistance: <span id="airResistanceVal">0.02</span></label>
      <button class="small-btn reset-btn" data-slider="airResistance" data-default="0.02">Reset</button>
    </div>
    <input type="range" id="airResistanceRange" min="0" max="1" step="0.01" value="0.02" />
  </div>
</div>

<div id="bondSettingsPanel">
  <div class="bond-type">
    <label><input type="radio" name="bondType" value="rigid" checked> Rigid</label>
    <label><input type="radio" name="bondType" value="loose"> Loose</label>
  </div>
</div>

<div id="dragSettingsPanel">
  <div class="checkbox-group">
    <label><input type="checkbox" id="dragAsMoveCheckbox" checked> Drag acts as Move</label>
  </div>
  <div class="checkbox-group">
    <label class="disabled"><input type="checkbox" id="smoothDragCheckbox" disabled> Experimental Smooth Drag</label>
  </div>
</div>

<!-- Add create settings panel with state tabs and color sliders -->
<div id="createSettingsPanel">
  <div class="state-tabs">
    <button id="solidTabBtn" class="active">Solid</button>
    <button id="liquidTabBtn">Liquid</button>
    <button id="gasTabBtn">Gas</button>
  </div>
  
  <div class="color-sliders">
    <div class="slider-header">
      <label>Color</label>
      <div class="button-group">
        <button id="resetColorBtn" class="small-btn">Reset Color</button>
        <button id="randomizeColorBtn" class="small-btn">Randomize Color</button>
      </div>
    </div>
    
    <label for="redSlider">R: <span id="redVal">10</span></label>
    <input type="range" id="redSlider" min="0" max="255" value="10" />
    
    <label for="greenSlider">G: <span id="greenVal">132</span></label>
    <input type="range" id="greenSlider" min="0" max="255" value="132" />
    
    <label for="blueSlider">B: <span id="blueVal">255</span></label>
    <input type="range" id="blueSlider" min="0" max="255" value="255" />
    
    <div class="color-preview" id="colorPreview"></div>
  </div>
</div>

<script>
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');

  // Add simulation state variables
  let isPaused = false;
  let animationFrameId = null;

  // Add freeze tool state
  let isFreezing = false;

  function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight - 50;
  }
  window.addEventListener('resize', resize);
  resize();

  // Add references to the create settings panel elements
  const createSettingsPanel = document.getElementById('createSettingsPanel');
  const solidTabBtn = document.getElementById('solidTabBtn');
  const liquidTabBtn = document.getElementById('liquidTabBtn');
  const gasTabBtn = document.getElementById('gasTabBtn');
  const redSlider = document.getElementById('redSlider');
  const greenSlider = document.getElementById('greenSlider');
  const blueSlider = document.getElementById('blueSlider');
  const redVal = document.getElementById('redVal');
  const greenVal = document.getElementById('greenVal');
  const blueVal = document.getElementById('blueVal');
  const colorPreview = document.getElementById('colorPreview');

  // Add reference to the reset color button
  const resetColorBtn = document.getElementById('resetColorBtn');

  // Add reference to the randomize color button
  const randomizeColorBtn = document.getElementById('randomizeColorBtn');

  // Function to generate a random color
  function getRandomColor() {
    return {
      r: Math.floor(Math.random() * 256),
      g: Math.floor(Math.random() * 256),
      b: Math.floor(Math.random() * 256)
    };
  }

  // Define default colors for each state
  const defaultColors = {
    solid: { r: 150, g: 150, b: 150 },   // Gray
    liquid: { r: 10, g: 132, b: 255 },   // Blue
    gas: { r: 80, g: 80, b: 80 }         // Dark Gray
  };

  // Reset color button handler
  resetColorBtn.onclick = () => {
    // Reset the current state's color to default
    currentColor[currentState] = { ...defaultColors[currentState] };
    updateColorPreview();
  };

  // Randomize color button handler
  randomizeColorBtn.onclick = () => {
    // Set the current state's color to a random color
    currentColor[currentState] = getRandomColor();
    updateColorPreview();
  };

  // Initialize state and color variables
  let currentState = 'solid';
  let currentColor = {
    solid: { r: 150, g: 150, b: 150 },   // Gray
    liquid: { r: 10, g: 132, b: 255 },   // Blue
    gas: { r: 80, g: 80, b: 80 }         // Dark Gray
  };

  // Function to update color preview
  function updateColorPreview() {
    const color = currentColor[currentState];
    colorPreview.style.background = `rgb(${color.r}, ${color.g}, ${color.b})`;
    redVal.textContent = color.r;
    greenVal.textContent = color.g;
    blueVal.textContent = color.b;
    redSlider.value = color.r;
    greenSlider.value = color.g;
    blueSlider.value = color.b;
  }

  // Function to set the current state
  function setState(state) {
    currentState = state;
    
    // Update tab buttons
    solidTabBtn.classList.toggle('active', state === 'solid');
    liquidTabBtn.classList.toggle('active', state === 'liquid');
    gasTabBtn.classList.toggle('active', state === 'gas');
    
    // Update color preview
    updateColorPreview();
  }

  // Tab button click handlers
  solidTabBtn.onclick = () => setState('solid');
  liquidTabBtn.onclick = () => setState('liquid');
  gasTabBtn.onclick = () => setState('gas');

  // Color slider handlers
  redSlider.oninput = () => {
    currentColor[currentState].r = parseInt(redSlider.value);
    redVal.textContent = currentColor[currentState].r;
    updateColorPreview();
  };

  greenSlider.oninput = () => {
    currentColor[currentState].g = parseInt(greenSlider.value);
    greenVal.textContent = currentColor[currentState].g;
    updateColorPreview();
  };

  blueSlider.oninput = () => {
    currentColor[currentState].b = parseInt(blueSlider.value);
    blueVal.textContent = currentColor[currentState].b;
    updateColorPreview();
  };

  class Circle {
    constructor(x, y, radius = 30) {
      this.x = x;
      this.y = y;
      this.radius = radius;
      this.breakCount = 3; // Fixed default value
      this.currentHits = 0;
      this.state = currentState;
      
      // Use the current color for the state
      const color = currentColor[currentState];
      this.color = `rgb(${color.r}, ${color.g}, ${color.b})`;

      this.vx = 0;
      this.vy = 0;
      this.mass = currentState === 'gas' ? 0.3 : 1;
      this.isBeingMoved = false;
      this.isBeingDragged = false;
      this.isFrozen = false;
    }

    draw(ctx) {
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
      ctx.fillStyle = this.color;
      ctx.fill();

      // Draw frozen indicator
      if (this.isFrozen) {
        ctx.strokeStyle = '#5856d6';
        ctx.lineWidth = 3;
        ctx.stroke();
      }
      
      // Removed the code that draws the number (breakCount - currentHits)
    }

    isPointInside(px, py) {
      const dx = px - this.x;
      const dy = py - this.y;
      return dx * dx + dy * dy <= this.radius * this.radius;
    }
  }

  class Bond {
    constructor(c1, c2, type) {
      this.c1 = c1;
      this.c2 = c2;
      this.type = type; // rigid or loose
      this.length = Math.hypot(c1.x - c2.x, c1.y - c2.y);
    }

    update() {
      const dx = this.c2.x - this.c1.x;
      const dy = this.c2.y - this.c1.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist === 0) return;

      const nx = dx / dist;
      const ny = dy / dist;

      switch (this.type) {
        case 'rigid':
          {
            const diff = dist - this.length;
            const offsetX = nx * diff * 0.5;
            const offsetY = ny * diff * 0.5;

            this.c1.x += offsetX;
            this.c1.y += offsetY;
            this.c2.x -= offsetX;
            this.c2.y -= offsetY;

            // Adjust velocities for collision effect
            this.c1.vx += offsetX * 0.1;
            this.c1.vy += offsetY * 0.1;
            this.c2.vx -= offsetX * 0.1;
            this.c2.vy -= offsetY * 0.1;
          }
          break;

        case 'loose':
          {
            // Only apply constraint if distance exceeds the original length
            if (dist > this.length) {
              // Apply rigid-like constraint to prevent exceeding the original length
              const diff = dist - this.length;
              const offsetX = nx * diff * 0.5;
              const offsetY = ny * diff * 0.5;

              // Move balls back to maintain maximum distance
              this.c1.x += offsetX;
              this.c1.y += offsetY;
              this.c2.x -= offsetX;
              this.c2.y -= offsetY;

              // Adjust velocities for collision effect
              this.c1.vx += offsetX * 0.1;
              this.c1.vy += offsetY * 0.1;
              this.c2.vx -= offsetX * 0.1;
              this.c2.vy -= offsetY * 0.1;
            }
            // If distance is less than original length, do nothing (free movement)
          }
          break;
      }
    }

    draw(ctx) {
      // Different colors for different bond types
      switch(this.type) {
        case 'rigid':
          ctx.strokeStyle = '#0a84ff'; // Blue
          break;
        case 'loose':
          ctx.strokeStyle = '#ff9f0a'; // Orange
          break;
        default:
          ctx.strokeStyle = '#0a84ff'; // Default blue
      }
      
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(this.c1.x, this.c1.y);
      ctx.lineTo(this.c2.x, this.c2.y);
      ctx.stroke();
    }
  }

  let circles = [];
  let bonds = [];

  let mode = 'create';
  let selectedCircle = null;
  let bondFirstCircle = null;

  const gravityInput = document.getElementById('gravityRange');
  let gravity = parseFloat(gravityInput.value);

  const dragStrengthInput = document.getElementById('dragStrengthRange');
  let dragStrength = parseFloat(dragStrengthInput.value);

  const airResistanceInput = document.getElementById('airResistanceRange');
  let airResistance = parseFloat(airResistanceInput.value);

  // Bond settings
  const bondSettingsPanel = document.getElementById('bondSettingsPanel');
  const bondTypeRadios = bondSettingsPanel.querySelectorAll('input[name="bondType"]');

  let bondType = 'rigid';

  // Initialize variables before they're used
  const dragAsMoveCheckbox = document.getElementById('dragAsMoveCheckbox');
  let dragAsMove = dragAsMoveCheckbox.checked; // Initialize based on checkbox state

  // Add reference to the smooth drag checkbox
  const smoothDragCheckbox = document.getElementById('smoothDragCheckbox');
  let smoothDrag = false; // Initialize as false

  // Update the dragAsMoveCheckbox event listener to toggle the smoothDragCheckbox
  dragAsMoveCheckbox.addEventListener('change', () => {
    dragAsMove = dragAsMoveCheckbox.checked;
    console.log(`Drag as Move: ${dragAsMove}`);
    
    // Toggle the smoothDragCheckbox based on dragAsMoveCheckbox state
    if (dragAsMove) {
      // Disable and uncheck the smoothDragCheckbox when dragAsMoveCheckbox is checked
      smoothDragCheckbox.disabled = true;
      smoothDragCheckbox.checked = false;
      smoothDrag = false;
      smoothDragCheckbox.parentElement.classList.add('disabled');
    } else {
      // Enable the smoothDragCheckbox when dragAsMoveCheckbox is unchecked
      smoothDragCheckbox.disabled = false;
      smoothDragCheckbox.parentElement.classList.remove('disabled');
    }
    
    // Reset any active dragging
    if (selectedCircle) {
      selectedCircle.isBeingMoved = false;
      selectedCircle = null;
    }
    if (draggedCircle) {
      draggedCircle.isBeingDragged = false;
      draggedCircle = null;
    }
  });

  // Add event listener for the smoothDragCheckbox
  smoothDragCheckbox.addEventListener('change', () => {
    smoothDrag = smoothDragCheckbox.checked;
    console.log(`Smooth Drag: ${smoothDrag}`);
    
    // Reset any active dragging
    if (draggedCircle) {
      draggedCircle.isBeingDragged = false;
      draggedCircle = null;
    }
  });

  // Bond settings handlers
  bondTypeRadios.forEach(radio => {
    radio.onchange = () => {
      if (radio.checked) bondType = radio.value;
    };
  });

  // Add reference to the drag settings panel
  const dragSettingsPanel = document.getElementById('dragSettingsPanel');

  // Function to position a panel above its button
  function positionPanelAboveButton(panel, button) {
    if (!panel || !button) return;
    
    const buttonRect = button.getBoundingClientRect();
    const panelRect = panel.getBoundingClientRect();
    
    // Center the panel horizontally over the button
    const left = buttonRect.left + (buttonRect.width / 2) - (panelRect.width / 2);
    
    // Position the panel above the button
    const bottom = window.innerHeight - buttonRect.top + 10;
    
    panel.style.left = `${Math.max(10, left)}px`;
    panel.style.bottom = `${bottom}px`;
    panel.style.transform = 'none'; // Remove the transform since we're setting position directly
  }

  // Update the setMode function to handle the new behavior
  function setMode(newMode) {
    // If clicking the same mode button that's already active, toggle the panel
    if (mode === newMode) {
      if (newMode === 'create') {
        // Toggle create settings panel
        const isVisible = createSettingsPanel.style.display === 'block';
        createSettingsPanel.style.display = isVisible ? 'none' : 'block';
        if (!isVisible) {
          positionPanelAboveButton(createSettingsPanel, createBtn);
          updateColorPreview();
        }
      } else if (newMode === 'bond') {
        // Toggle bond settings panel
        const isVisible = bondSettingsPanel.style.display === 'block';
        bondSettingsPanel.style.display = isVisible ? 'none' : 'block';
        if (!isVisible) {
          positionPanelAboveButton(bondSettingsPanel, bondBtn);
        }
      } else if (newMode === 'settings') {
        // Toggle settings panel
        const isVisible = settingsPanel.style.display === 'block';
        settingsPanel.style.display = isVisible ? 'none' : 'block';
        if (!isVisible) {
          positionPanelAboveButton(settingsPanel, settingsBtn);
        }
      } else if (newMode === 'drag') {
        // Toggle drag settings panel
        const isVisible = dragSettingsPanel.style.display === 'block';
        dragSettingsPanel.style.display = isVisible ? 'none' : 'block';
        if (!isVisible) {
          positionPanelAboveButton(dragSettingsPanel, dragBtn);
        }
      }
      return; // Keep the same mode, just toggle the panel
    }

    console.log(`Setting mode to: ${newMode}, state: ${currentState}`);
    mode = newMode;
    
    // Remove active class from all buttons
    [createBtn, dragBtn, bondBtn, freezeBtn, settingsBtn].forEach(btn => btn.classList.remove('active'));
    
    // Add active class to the appropriate button
    if (newMode === 'create') createBtn.classList.add('active');
    else if (newMode === 'drag') dragBtn.classList.add('active');
    else if (newMode === 'bond') bondBtn.classList.add('active');
    else if (newMode === 'freeze') freezeBtn.classList.add('active');
    else if (newMode === 'settings') settingsBtn.classList.add('active');

    // Hide all panels when switching modes
    createSettingsPanel.style.display = 'none';
    settingsPanel.style.display = 'none';
    bondSettingsPanel.style.display = 'none';
    dragSettingsPanel.style.display = 'none';

    // Reset selection states
    selectedCircle = null;
    bondFirstCircle = null;
    draggedCircle = null;
  }

  // Toolbar buttons
  const createBtn = document.getElementById('createBtn');
  const dragBtn = document.getElementById('dragBtn');
  const bondBtn = document.getElementById('bondBtn');
  const settingsBtn = document.getElementById('settingsBtn');
  const resetBtn = document.getElementById('resetBtn');

  createBtn.onclick = () => setMode('create');
  dragBtn.onclick = () => setMode('drag');
  bondBtn.onclick = () => setMode('bond');
  settingsBtn.onclick = () => setMode('settings');
  resetBtn.onclick = () => {
    circles = [];
    bonds = [];
  };

  // Settings panel handlers
  gravityInput.oninput = () => {
    gravity = parseFloat(gravityInput.value);
    document.getElementById('gravityVal').textContent = gravity.toFixed(1);
  };

  dragStrengthInput.oninput = () => {
    dragStrength = parseFloat(dragStrengthInput.value);
    document.getElementById('dragStrengthVal').textContent = dragStrength.toFixed(2);
  };

  airResistanceInput.oninput = () => {
    airResistance = parseFloat(airResistanceInput.value);
    document.getElementById('airResistanceVal').textContent = airResistance.toFixed(3);
  };

  // Add reset button handlers
  const resetButtons = document.querySelectorAll('.reset-btn');
  resetButtons.forEach(button => {
    button.addEventListener('click', () => {
      const sliderName = button.getAttribute('data-slider');
      const defaultValue = parseFloat(button.getAttribute('data-default'));
      
      // Reset the slider value
      if (sliderName === 'gravity') {
        gravity = defaultValue;
        gravityInput.value = defaultValue;
        document.getElementById('gravityVal').textContent = defaultValue.toFixed(1);
      } else if (sliderName === 'dragStrength') {
        dragStrength = defaultValue;
        dragStrengthInput.value = defaultValue;
        document.getElementById('dragStrengthVal').textContent = defaultValue.toFixed(2);
      } else if (sliderName === 'airResistance') {
        airResistance = defaultValue;
        airResistanceInput.value = defaultValue;
        document.getElementById('airResistanceVal').textContent = defaultValue.toFixed(3);
      }
    });
  });

  // Bond settings handlers
  bondTypeRadios.forEach(radio => {
    radio.onchange = () => {
      if (radio.checked) bondType = radio.value;
    };
  });

  // Add pause button handler
  const pauseBtn = document.getElementById('pauseBtn');
  pauseBtn.onclick = () => {
    isPaused = !isPaused;
    pauseBtn.textContent = isPaused ? 'Resume' : 'Pause';
    pauseBtn.classList.toggle('paused', isPaused);
    
    if (!isPaused && !animationFrameId) {
      loop();
    }
  };

  // Add freeze button to toolbar
  const freezeBtn = document.getElementById('freezeBtn');
  freezeBtn.onclick = () => setMode('freeze');

  // Utilities
  function getCircleAtPos(x, y) {
    return circles.find(c => c.isPointInside(x, y));
  }

  // Mouse state
  let mouseX = 0;
  let mouseY = 0;
  let mouseDown = false;

  // Add smoothing variables for drag movement
  let lastMouseX = 0;
  let lastMouseY = 0;
  const dragSmoothingFactor = 0.3; // Lower = smoother but more lag

  // Drag tool vars
  let draggedCircle = null;

  canvas.oncontextmenu = e => e.preventDefault();

  canvas.addEventListener('mousedown', e => {
    lastMouseX = e.clientX;
    lastMouseY = e.clientY;
    mouseX = lastMouseX;
    mouseY = lastMouseY;
    mouseDown = true;

    if (mode === 'create' && e.button === 0) {
      circles.push(new Circle(mouseX, mouseY, 30)); // Removed breakCount parameter
    } else if (mode === 'drag' && e.button === 0) {
      const clickedCircle = getCircleAtPos(mouseX, mouseY);
      if (clickedCircle) {
        if (dragAsMove) {
          // Act like move tool
          selectedCircle = clickedCircle;
          selectedCircle.isBeingMoved = true;
        } else {
          // Act like drag tool
          draggedCircle = clickedCircle;
          draggedCircle.isBeingDragged = true;
        }
      }
    } else if (mode === 'bond' && e.button === 0) {
      let clickedCircle = getCircleAtPos(mouseX, mouseY);
      if (clickedCircle) {
        if (!bondFirstCircle) {
          bondFirstCircle = clickedCircle;
        } else if (bondFirstCircle !== clickedCircle) {
          // Add bond if not already bonded
          if (!bonds.some(b => (b.c1 === bondFirstCircle && b.c2 === clickedCircle) || (b.c2 === bondFirstCircle && b.c1 === clickedCircle))) {
            bonds.push(new Bond(bondFirstCircle, clickedCircle, bondType));
          }
          bondFirstCircle = null;
        }
      }
    } else if (mode === 'freeze' && e.button === 0) {
      const clickedCircle = getCircleAtPos(mouseX, mouseY);
      if (clickedCircle) {
        // Toggle frozen state
        clickedCircle.isFrozen = !clickedCircle.isFrozen;
      }
    }
  });

  canvas.addEventListener('mouseup', e => {
    mouseX = e.clientX;
    mouseY = e.clientY;
    mouseDown = false;

    if (mode === 'drag') {
      if (dragAsMove && selectedCircle) {
        selectedCircle.isBeingMoved = false;
        selectedCircle = null;
      } else if (!dragAsMove && draggedCircle) {
        draggedCircle.isBeingDragged = false;
        draggedCircle = null;
      }
    }
  });

  canvas.addEventListener('mousemove', e => {
    // Apply smoothing to mouse coordinates
    const rawMouseX = e.clientX;
    const rawMouseY = e.clientY;
    
    if (smoothDrag && mode === 'drag' && !dragAsMove && draggedCircle) {
      // Smooth the mouse movement
      mouseX = lastMouseX + (rawMouseX - lastMouseX) * dragSmoothingFactor;
      mouseY = lastMouseY + (rawMouseY - lastMouseY) * dragSmoothingFactor;
      
      // Update last positions for next frame
      lastMouseX = mouseX;
      lastMouseY = mouseY;
    } else {
      // No smoothing
      mouseX = rawMouseX;
      mouseY = rawMouseY;
      lastMouseX = mouseX;
      lastMouseY = mouseY;
    }

    if (mode === 'drag' && dragAsMove && selectedCircle && selectedCircle.isBeingMoved) {
      // Calculate movement delta
      const dx = mouseX - selectedCircle.x;
      const dy = mouseY - selectedCircle.y;
      
      // Move the selected circle directly to the mouse position
      selectedCircle.x = mouseX;
      selectedCircle.y = mouseY;
      selectedCircle.vx = 0;
      selectedCircle.vy = 0;
      
      // Find all circles directly and indirectly bonded to the selected circle
      const bondedCircles = new Set();
      
      // First, find all directly bonded circles
      for (let b of bonds) {
        if (b.c1 === selectedCircle) {
          bondedCircles.add(b.c2);
        } else if (b.c2 === selectedCircle) {
          bondedCircles.add(b.c1);
        }
      }
      
      // Then find all circles bonded to those circles (recursive)
      let newBondedFound = true;
      while (newBondedFound) {
        newBondedFound = false;
        for (let b of bonds) {
          if (bondedCircles.has(b.c1) && b.c2 !== selectedCircle && !bondedCircles.has(b.c2)) {
            bondedCircles.add(b.c2);
            newBondedFound = true;
          } else if (bondedCircles.has(b.c2) && b.c1 !== selectedCircle && !bondedCircles.has(b.c1)) {
            bondedCircles.add(b.c1);
            newBondedFound = true;
          }
        }
      }
      
      // Move all bonded circles by the same delta
      for (let c of bondedCircles) {
        c.x += dx;
        c.y += dy;
        c.vx = 0;
        c.vy = 0;
      }
    }
  });

  canvas.addEventListener('contextmenu', e => {
    e.preventDefault();
    const cx = e.clientX;
    const cy = e.clientY;
    // Right-click deletes circle
    for (let i = circles.length - 1; i >= 0; i--) {
      if (circles[i].isPointInside(cx, cy)) {
        // Remove bonds related to this circle
        bonds = bonds.filter(b => b.c1 !== circles[i] && b.c2 !== circles[i]);
        circles.splice(i, 1);
        break;
      }
    }
  });

  function updatePhysics() {
    if (isPaused) return;

    // Update physics for circles
    for (let c of circles) {
      // Skip physics for frozen circles
      if (c.isFrozen) continue;
      
      if (!c.isBeingMoved) {
        if (!c.isBeingDragged) {
          c.vy += gravity;
          c.vx *= (1 - airResistance);
          c.vy *= (1 - airResistance);
        } else {
          // Apply drag force
          const dx = mouseX - c.x;
          const dy = mouseY - c.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          if (smoothDrag) {
            if (dist > 0) {
              // Calculate normalized direction
              const nx = dx / dist;
              const ny = dy / dist;
              
              // Calculate proximity factor (1 when far, 0 when very close)
              const proximityFactor = Math.min(1, dist / 100);
              
              // Calculate damping factor (stronger when close to mouse)
              const dampingFactor = 0.8 + (1 - proximityFactor) * 0.15;
              
              // Apply strong velocity damping when close to target
              c.vx *= dampingFactor;
              c.vy *= dampingFactor;
              
              // Calculate force based on distance
              // Reduce force when very close to prevent overshooting
              const forceFactor = proximityFactor * dragStrength;
              
              // Apply force
              c.vx += dx * forceFactor;
              c.vy += dy * forceFactor;
              
              // Add gravity (reduced when close to target)
              c.vy += gravity * proximityFactor;
              
              // Apply air resistance (increased when close to target)
              const effectiveAirResistance = airResistance + (1 - proximityFactor) * 0.2;
              c.vx *= (1 - effectiveAirResistance);
              c.vy *= (1 - effectiveAirResistance);
              
              // When very close to target and moving slowly, snap to position
              if (dist < 5 && Math.abs(c.vx) < 0.5 && Math.abs(c.vy) < 0.5) {
                c.vx = 0;
                c.vy = 0;
              }
            }
          } else {
            // Regular drag
            c.vx += dx * dragStrength;
            c.vy += dy * dragStrength;
            c.vy += gravity;
            c.vx *= (1 - airResistance);
            c.vy *= (1 - airResistance);
          }
        }
      }
      
      // Update position
      c.x += c.vx;
      c.y += c.vy;
      
      // Bounce off edges
      if (c.x - c.radius < 0) {
        c.x = c.radius;
        c.vx = -c.vx * 0.7;
      }
      if (c.x + c.radius > canvas.width) {
        c.x = canvas.width - c.radius;
        c.vx = -c.vx * 0.7;
      }
      if (c.y + c.radius > canvas.height) {
        c.y = canvas.height - c.radius;
        c.vy = -c.vy * 0.7;
        if (Math.abs(c.vy) < 1) c.vy = 0;
      }
      if (c.y - c.radius < 0) {
        c.y = c.radius;
        c.vy = -c.vy * 0.7;
      }
    }

    // Bonds apply forces and constraints, but respect frozen circles
    for (let b of bonds) {
      // Skip bond physics if both ends are frozen
      if (b.c1.isFrozen && b.c2.isFrozen) continue;
      
      // If one end is frozen, only move the other end
      const originalUpdate = b.update;
      b.update = function() {
        if (b.c1.isFrozen) {
          // Only move c2
          const dx = b.c2.x - b.c1.x;
          const dy = b.c2.y - b.c1.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist === 0) return;
          
          const nx = dx / dist;
          const ny = dy / dist;
          
          if (this.type === 'rigid' || (this.type === 'loose' && dist > this.length)) {
            const diff = dist - this.length;
            b.c2.x = b.c1.x + nx * this.length;
            b.c2.y = b.c1.y + ny * this.length;
            b.c2.vx += nx * diff * 0.1;
            b.c2.vy += ny * diff * 0.1;
          }
        } else if (b.c2.isFrozen) {
          // Only move c1
          const dx = b.c2.x - b.c1.x;
          const dy = b.c2.y - b.c1.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist === 0) return;
          
          const nx = dx / dist;
          const ny = dy / dist;
          
          if (this.type === 'rigid' || (this.type === 'loose' && dist > this.length)) {
            const diff = dist - this.length;
            b.c1.x = b.c2.x - nx * this.length;
            b.c1.y = b.c2.y - ny * this.length;
            b.c1.vx -= nx * diff * 0.1;
            b.c1.vy -= ny * diff * 0.1;
          }
        } else {
          // Normal update if neither end is frozen
          originalUpdate.call(this);
        }
      };
      
      b.update();
    }

    // Collide all balls, respecting frozen state
    for (let i = 0; i < circles.length; i++) {
      for (let j = i + 1; j < circles.length; j++) {
        // If both circles are frozen, skip collision
        if (circles[i].isFrozen && circles[j].isFrozen) continue;
        
        collideCircles(circles[i], circles[j]);
      }
    }
  }

  function isBonded(c1, c2) {
    return bonds.some(b => (b.c1 === c1 && b.c2 === c2) || (b.c2 === c1 && b.c1 === c2));
  }

  function collideCircles(c1, c2) {
    const dx = c2.x - c1.x;
    const dy = c2.y - c1.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    const minDist = c1.radius + c2.radius;
    if (dist < minDist && dist > 0) {
      const overlap = 0.5 * (minDist - dist);

      const nx = dx / dist;
      const ny = dy / dist;

      // Check if either circle is being moved directly by the user
      const c1IsBeingMoved = c1.isBeingMoved || (mode === 'drag' && dragAsMove && selectedCircle === c1);
      const c2IsBeingMoved = c2.isBeingMoved || (mode === 'drag' && dragAsMove && selectedCircle === c2);

      // Displace circles to avoid overlap, respecting frozen state and direct movement
      if (!c1.isFrozen && !c2.isFrozen) {
        if (c1IsBeingMoved && !c2IsBeingMoved) {
          // If c1 is being moved directly, only move c2
          c2.x += nx * overlap * 2;
          c2.y += ny * overlap * 2;
        } else if (!c1IsBeingMoved && c2IsBeingMoved) {
          // If c2 is being moved directly, only move c1
          c1.x -= nx * overlap * 2;
          c1.y -= ny * overlap * 2;
        } else {
          // If neither or both are being moved, move both equally
          c1.x -= nx * overlap;
          c1.y -= ny * overlap;
          c2.x += nx * overlap;
          c2.y += ny * overlap;
        }
      } else if (c1.isFrozen && !c2.isFrozen) {
        // If c1 is frozen, only move c2
        c2.x += nx * overlap * 2;
        c2.y += ny * overlap * 2;
      } else if (!c1.isFrozen && c2.isFrozen) {
        // If c2 is frozen, only move c1
        c1.x -= nx * overlap * 2;
        c1.y -= ny * overlap * 2;
      }
      // If both are frozen, do nothing

      // Reflect velocities for elastic collision (simplified)
      // Only apply to non-frozen circles and respect direct movement
      if (!c1.isFrozen && !c2.isFrozen) {
        if (c1IsBeingMoved && !c2IsBeingMoved) {
          // If c1 is being moved directly, only affect c2's velocity
          c2.vx = c2.vx + nx * Math.abs(c1.vx) * 1.4;
          c2.vy = c2.vy + ny * Math.abs(c1.vy) * 1.4;
        } else if (!c1IsBeingMoved && c2IsBeingMoved) {
          // If c2 is being moved directly, only affect c1's velocity
          c1.vx = c1.vx - nx * Math.abs(c2.vx) * 1.4;
          c1.vy = c1.vy - ny * Math.abs(c2.vy) * 1.4;
        } else {
          // Normal collision if neither or both are being moved
          const kx = (c1.vx - c2.vx);
          const ky = (c1.vy - c2.vy);
          const p = 2 * (nx * kx + ny * ky) / (c1.mass + c2.mass);

          c1.vx = c1.vx - p * c2.mass * nx;
          c1.vy = c1.vy - p * c2.mass * ny;
          c2.vx = c2.vx + p * c1.mass * nx;
          c2.vy = c2.vy + p * c1.mass * ny;
        }
      } else if (c1.isFrozen && !c2.isFrozen) {
        // If c1 is frozen, only affect c2's velocity
        const kx = -c2.vx;
        const ky = -c2.vy;
        const p = 2 * (nx * kx + ny * ky);
        
        c2.vx = c2.vx + p * nx;
        c2.vy = c2.vy + p * ny;
      } else if (!c1.isFrozen && c2.isFrozen) {
        // If c2 is frozen, only affect c1's velocity
        const kx = c1.vx;
        const ky = c1.vy;
        const p = 2 * (nx * kx + ny * ky);
        
        c1.vx = c1.vx - p * nx;
        c1.vy = c1.vy - p * ny;
      }
    }
  }

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Draw bonds
    for (let b of bonds) {
      b.draw(ctx);
    }

    // Draw circles
    for (let c of circles) {
      c.draw(ctx);
    }

    // Draw drag line if dragging
    if (mode === 'drag' && !dragAsMove && draggedCircle && draggedCircle.isBeingDragged) {
      ctx.strokeStyle = '#0a84ff';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(mouseX, mouseY);
      ctx.lineTo(draggedCircle.x, draggedCircle.y);
      ctx.stroke();
    }

    // Draw bond selection line
    if (mode === 'bond' && bondFirstCircle) {
      ctx.strokeStyle = '#0aff99';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(bondFirstCircle.x, bondFirstCircle.y);
      ctx.lineTo(mouseX, mouseY);
      ctx.stroke();
    }
  }

  function loop() {
    try {
      updatePhysics();
      draw();
      animationFrameId = requestAnimationFrame(loop);
    } catch (error) {
      console.error("Error in animation loop:", error);
    }
  }

  loop();

  // Reposition panels when window is resized
  window.addEventListener('resize', () => {
    if (createSettingsPanel.style.display === 'block') {
      positionPanelAboveButton(createSettingsPanel, createBtn);
    }
    if (settingsPanel.style.display === 'block') {
      positionPanelAboveButton(settingsPanel, settingsBtn);
    }
    if (bondSettingsPanel.style.display === 'block') {
      positionPanelAboveButton(bondSettingsPanel, bondBtn);
    }
    if (dragSettingsPanel.style.display === 'block') {
      positionPanelAboveButton(dragSettingsPanel, dragBtn);
    }
  });

  // Initialize the color preview
  updateColorPreview();
</script>

</body>
</html>


